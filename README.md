# Implementation of Case-Based Reasoning for Pokemon Battle Rematches
(This is not final and will update as time goes on with modifying the code again and updating my description and videos)

Simple Implementation of Case-Based Reasoning (CBR) for pokemon battle rematches of the AI in the game. Not advanced but a foundation based on my current understanding of the pillars of CBR (Retain, Retrieve, Reuse, and Revise) and the code in this Decomp. Future work from either me or whoever wishes to work on it with better experience with the code or understanding to make it more advanced is encouraged since this isn't a final form of the project. Some Future work can be to make the storage more dynamic since it only can hold a constant value amount of information for both the one gym leader and the users team based on SaveBlock3 in `global.h`.

## Important
Recordings of the CBR project is located in `Case-Based Reasoning Project Videos`.
Inside that folder is 3 parts of an entire video which are:
- Part 1 Contains the default battle initially with the NPC before any CBR is active.
- Part 2 Rematch of NPC with CBR implementation based on AI losing from prior match
- Part 3 Rematch of NPC with CBR implementation based on AI wining from prior match

# Project Description
## Overview of Case-Based Reasoning
Case-Based Reasoning is a form of Artificial Intelligence that focuses on an experience-based approache. In storing information from the current task at hand or situation (For example a pokemon match against the NPC) it can then utilize such information for future events that it encounters that are of similarity. In doing so it can act differently depending on the information stored from the prior match and then from this new action taken see if it improved or not afterwards. All of this it to make the agent have an improved decision-making capability. 
In order for the implementation of Case-Based Reasoning to occur there are four foundational steps that are needed. These four steps are Retain, Retrieve, Reuse, and Revise (The four Rs) and each of them play a role of varying size depending on the situation at hand that we wish to create it for. 
The purpose of each are:
1. Retain: Acquire information of the situation during execution or fed old data that is already stored so that it can be used for future occurences. 
2. Retrieve: Gather the best similar case from the storage. 
3. Reuse: Apply that retrieved case to the current task at hand.
4. Revise: Check the effectiveness of applying said case and to update and store the new gained experience.

For my situation, which is for Pokemon Emerald Battles, the four steps are followed but are modified to fit into that usage for the AI of the game. I modified LittleRoot Town (So its scripts and JSON files) to implement all the Gym Leaders into the map and did all of my testing and implementation using Roxanne. For this I gave her a full team of 6 that scaled with my teams levels, and some healing items. This also only works for post game matches effectively so future work needed to make it have ability to check users and ai's party evolutions to modify its decision-making. With an overview of what CBR is and what was set up I will now below talk about the four R's and what I did to implement and modify for it to improve the ai logic for pokemon battles. The files for this implementation are talked about below with a description of what was added or modified.

### Retain
In order to store specific data from a battle I first looked through the files for ones that involved ai battle logic. For this I used the built in DebugPrintfLevel printing statement for the decomp to display output to the log of the mGBA software used to play the game. Through this I found storing information through the `RecordKnownMove` function from `battle_ai_util.c` to work where it stores both user and npc's current pokemon, move, and typing of both pokemon and move used during each turn. If said pokemon uses the same move again during the match it won't activate and store that information again. It only will store new information it hasn't seen before. 

Now to store this information I used one of the three built in structs of the decomp for storing current player progress in the game. The newest one that was added into the decomp that I used is `SaveBlock3` which can be found in `global.h`. Here I have defined macros that are then used for the arrays stored in the saveblock which are called in the `RecordKnownMove` through the use of the external pointer for saveblock3 you can see in `global.h`. With this struct able to store information from the match I can then move onto the rest of the steps in CBR which will use `SaveBlock3`.

** See "Case-Based Reasoning Part 1.mp4" found in `Case-Based Reasoning Project Videos` folder of storing data **

### Retrieve
After information is stored from the first match I then went into `trainers.h` and looked at all that is assigned for each specific trainer. Following a pokeemerald wiki on how to make my own ai flag I created mine named, `AI_FLAG_ADAPTIVE_AI` where I will attach this flag at the end of `TRAINER_ROXANNE_2` (in `trainers.h`). I also as mentioned earlier updated the other Roxanne party calls after `TRAINER_ROXANNE_1` for the rematch in `trainer_parties.h`, and with the ai flag set up and the parties matching as they did for the default match. In the `battle_ai.h` all the ai flags with their specific purposes are listed there including the adaptive flag I created. At first I was going to make all the logic on my own but due to the update of `AI_FLAG_SMART_MON_CHOICES` I looked through it and saw it has most of what I wished to use for my CBR logic. I therefore went through and found all instances of the smart-mon-choices flag being called and replaced them with my adaptive flag. With my flag now in the smart-mon-choices place I moved on and added in my own for loops and conditionals to retrieve my stored information inside the `battle_ai_switch_item.c`, particularly the `HasBadOdds` function. 

In the `HasBadOdds` I retrieve stored data from saveblock3 and store the pokemon of the user and the npc that are currently out on the field into their own respective u16 variables. This does update after each turn so if you switch out it will display on the debug print statement what the current pokemon is. In this function I also am able to retrieve the moves correctly from their respective pokemon, including the outcome of the battles where the outcome of if the ai won or lost is stored from within the `Cmd_checkteamslost` function from `battle_script_commands.c`. The outcome part plays mostly into the revising part of CBR which I'll get into later down below in the revise section.
Once I was able to show that it does indeed retrieve and display correctly the pokemon that were of the user or npc I then moved onto how to reuse such information.

### Reuse
For the parts where the debug print displays when the battle starts or ends these are done in `CB2_HandleStartBattle` and `HandleEndTurn_FinishBattle` respectively from `battle_main.c` and just look for DebugPrintfLevel. Within what I have displayed I also have it showing if the ai won or lost the current match before it prints out the battle ended. With the outcomes being stored in `SaveBlock3` as well, they can be retrieved and used for the revising step of CBR. 

For the reusing part of the CBR I have the ai work by checking to see if it has encountered the users pokemon on the field currently with what it knows from `SaveBlock3`. To do this I first have in the `GetMostSuitableMonToSwitchInto` from `battle_ai_switch_items.c` a conditional where it will check if the ai has certain flags set, and for this to see if the `TRAINER_ROXANNE_2` from `trainers.h` has the ai flag `AI_FLAG_ADAPTIVE_AI`. if this flag is set it will jump into `GetBestMonIntegrated` which is also in `battle_ai_switch_items.c` and use all of its logic instead. For if the ai will decide to switch in or not it is switching is affected universally within `ShouldSwitch` where it too will activate the `HasBadOdds` and other functions depending on if `AI_FLAG_ADAPTIVE_AI` is set up for the npc. If the flag is not set some of these functions will work still since the game does have a default ai logic of its own that imitates the actual pokemon emerald games. So the ai would not switch out much or at all, and if it does it's not good at picking a suitable pokemon to switch into. It's just with the flag set it will improve the ai logic which will activate all the switch functions while using the `GetBestMonIntegrated` at the same time to make it choose a better pokemon to switch into. Also, with the flag set it will then continue through `HasBadOdds` where we see on line 171 what was created to display for the ai all the moves that it knows that the user picked from the prior match. During this time it will go though each of the moves and the logic will also display the damage each move can produce with the highest one shown and used further down in the logic of switching or not. The move with the highest damage possible will be used to check if it is greater than the current ai's pokemons health and if it is will return that it can be one-shot. More of this is used during the revising part below.

** See "Case-Based Reasoning Part 2.mp4" found in `Case-Based Reasoning Project Videos` folder of rematch after Lost outcome **

### Revise
For the Revise part of CBR it is not much but it will take the outcome from the prior match to update chances of the ai switching in or staying out. The ai losing or winning will have that outcome stored and this is all done in `Cmd_checkteamslost` from `battle_script_commands.c`. Once that is stored we go back into `HasBadOdds` in `battle_ai_switch_item.c` and retrieve the won or lost outcome in a variable labeled outcome. Line 220 within this function is where the chances of the ai staying in is created and returned from. Here I modified it to have three different conditions where the last one is the default one used either way if the flag was set or not. If there is no stored outcome even with the flag set then it will assume this is the first time fighting the npc so will default to the 50% chance of staying in. The first two checks are what I use for rematches where depending on if the ai won or lost the chances of staying in are increased or decreased respectively. If the outcome was that the ai lost which is usually true since most users will pick up typing and matchup very quickly and win, then the chances of the ai staying in will drop as can be seen by the `Random() % 5 == 0`. Also it first will check based on prior checks of the users moves that are known if it can get one-shot by the user. If the user does have a move that can possibly one-shot the pokemon of the ai a second conditional of the `getOneShot` is placed in there to increase even more the chance that the ai will choose to switch out instead of staying in. Though, again this is not always a guarantee as to make sure that even with the chances of switching in is increased or decreased it won't always so as to make it is not predictable to the user as possible. If the ai outcome was of winning the prior match than the chances of staying in is increased to be of greater than 50% chance `(Random() % 100) > 50` of staying so barely greater than default. Again the main point of this is to check the outcome of the prior match, and if the match is a lose or win it will stay in more or less respectively.  

** See "Case-Based Reasoning Part 3.mp4" found in `Case-Based Reasoning Project Videos` folder of rematch after Won outcome **

## Conclusion
With these four steps I am able to implement a basic CBR that stores information from both user and npc, retrieve such information once you rematch the npc, depending on if the ai flag is set it will change what will be activated or not for the reuse part, and finally based on the outcome it revises the ai's logic of switching out or not.  
